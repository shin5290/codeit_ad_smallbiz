# 업종 확대 및 구조 변경 분석 보고서

**작성일:** 2026년 1월 19일
**문서 유형:** 기술 분석 및 변경 제안서
**대상 파일:**
- `src/generation/image_generation/prompt/config/industries.yaml` (이전 버전)
- `scripts/신승목/industries.yaml` (이후 버전)

---

## 1. 요약

본 보고서는 이미지 생성 프롬프트 시스템에서 `industries.yaml`의 구조 변경에 따른 코드 수정 사항을 분석합니다.

### 주요 변경 사항
| 항목 | 이전 버전 (v2.0.0) | 이후 버전 (v3.0.0) |
|------|-------------------|-------------------|
| 업종 수 | 10개 (flat 구조) | 247개 (계층 구조) |
| 구조 | 단일 레벨 업종 코드 | 6개 등급 (S~E) + 18개 하위 그룹 |
| 업종 코드 | `cafe`, `gym`, `bakery` 등 | `s1_hot_cooking`, `a1_beauty` 등 |
| 접근 방식 | `config.get("cafe")` | `config["s_grade"]["s1_hot_cooking"]` |

### 영향 범위
- **config_loader.py**: 업종 로드 및 감지 로직 전면 수정 필요
- **prompt_manager.py / prompt_manager_sdxl.py**: 업종 감지 로직 수정 필요
- **prompt_templates.py / prompt_templates_sdxl.py**: 템플릿 빌더 호환성 유지
- **style_router.py**: 수정 불필요

---

## 2. 현재 시스템 구조 분석

### 2.1 프롬프트 생성 파이프라인

```
[사용자 입력 (한글)]
        ↓
[prompt_manager.py]
  - PromptTemplateManager.generate_detailed_prompt()
  - _detect_industry() → 업종 자동 감지
  - _get_industry_reference_keywords() → YAML 참조 키워드 추출
        ↓
[config_loader.py]
  - IndustryConfigLoader.get_industry(industry_code)
  - IndustryConfigLoader.detect_industry(user_input)
        ↓
[industries.yaml]
  - 업종별 prompt_template 로드
        ↓
[prompt_templates.py / prompt_templates_sdxl.py]
  - HybridPromptBuilder.build_from_user_input()
  - PromptStructure 생성
        ↓
[style_router.py]
  - StyleRouter.build_subject_phrase()
  - 스타일별 프롬프트 조정
        ↓
[최종 프롬프트 출력]
```

### 2.2 현재 industries.yaml 구조 (이전 버전)

```yaml
# Flat 구조 - 직접 접근 가능
cafe:
  name: "Cafe / Coffee Shop"
  name_ko: "카페"
  prompt_template:
    subject_patterns: [...]
    setting_patterns: [...]
    ...
  keywords: [latte, coffee, ...]
  negative_keywords: [...]

gym:
  name: "Gym / Fitness Center"
  ...

# 10개 업종: cafe, gym, laundry, bakery, restaurant,
#           hair_salon, nail_salon, flower_shop, clothing_store, general
```

### 2.3 핵심 코드 분석

#### config_loader.py의 주요 메서드

```python
class IndustryConfigLoader:
    def get_industry(self, industry_code: str) -> Optional[Dict]:
        """업종 설정 가져오기 - 직접 접근"""
        return self.config.get(industry_code)  # ← 현재: flat 접근

    def get_all_industries(self) -> Dict[str, Dict]:
        """모든 업종 설정 반환"""
        exclude = ['metadata', 'common_negative']
        return {k: v for k, v in self.config.items() if k not in exclude}

    def detect_industry(self, user_input: str) -> str:
        """업종 자동 감지 - 하드코딩된 키워드"""
        industry_keywords = {
            "cafe": ["카페", "커피", "라떼", ...],
            "gym": ["헬스", "운동", ...],
            ...
        }
```

---

## 3. 신규 industries.yaml 구조 분석 (이후 버전)

### 3.1 계층 구조

```yaml
# 계층 구조 - 등급 → 하위 그룹 → 개별 업종
s_grade:
  name: "S Grade - Sensory & Taste Stimulation"
  name_ko: "S등급 - 감성 및 미각 자극"
  characteristics: "High B2C, High Visual Dependency, High Competition"
  core_strategy: "Taste Visualization - ..."
  total_businesses: 70

  s1_hot_cooking:
    name: "S-1: Hot Cooking & Juicy Emphasis"
    name_ko: "S-1: 고온 조리 및 육즙 강조"
    count: 19
    businesses:
      - "Pork BBQ/Braised"
      - "Beef BBQ/Braised"
      - "Fried Chicken"
      ...
    visual_core: "Juiciness, steam rising, ..."
    prompt_template:
      subject_patterns: [...]
      setting_patterns: [...]
      ...
    required_layers: [subject, setting, lighting, details]
    keywords: [grilled, sizzling, hot, ...]
    negative_keywords: [burnt, plastic look, ...]

  s2_freshness:
    ...

a_grade:
  ...

b_grade:
  ...

c_grade:
  ...

d_grade:
  ...

e_grade:
  ...

common_negative:
  base: [...]
  realistic_exclusions: [...]
  quality_spam_avoid: [...]

guidelines:
  prompt_construction: {...}
  negative_construction: {...}
  ...

metadata:
  version: "3.0.0"
  total_grades: 6
  total_subgroups: 18
  total_businesses: 247
```

### 3.2 구조 비교 요약

| 구분 | 이전 버전 | 이후 버전 |
|------|----------|----------|
| 접근 경로 | `config["cafe"]` | `config["s_grade"]["s3_emotional"]` |
| 업종 식별자 | 단순 문자열 (`cafe`) | 복합 경로 (`s_grade/s3_emotional`) 또는 `s3_emotional` |
| 업종 목록 위치 | 없음 (업종 자체가 키) | `businesses` 배열에 포함 |
| 공통 전략 | 없음 | 등급별 `core_strategy`, `characteristics` |
| 세부 분류 | 없음 | `visual_core`, `count` 등 추가 메타데이터 |

---

## 4. 필요한 코드 변경 사항

### 4.1 config_loader.py 수정

#### 4.1.1 IndustryConfigLoader 클래스 개선

```python
class IndustryConfigLoader:
    """
    industries.yaml 로더 (v3.0.0 계층 구조 지원)

    한글 키워드는 YAML의 korean_keywords 필드에서 직접 로드
    """

    # 등급 목록 상수
    GRADES = ['s_grade', 'a_grade', 'b_grade', 'c_grade', 'd_grade', 'e_grade']

    def __init__(self, config_path: Optional[str] = None):
        if config_path is None:
            self.config_path = Path(__file__).parent / "config" / "industries.yaml"
        else:
            self.config_path = Path(config_path)
        self.config = self._load_config()

        # 캐시: 하위 그룹 코드 → (등급, 하위그룹 데이터) 매핑
        self._subgroup_cache = self._build_subgroup_cache()

        # 캐시: 업종명 → 하위 그룹 코드 매핑
        self._business_to_subgroup = self._build_business_mapping()

        # 캐시: 하위 그룹별 키워드 맵 (영어 + 한글)
        self._keyword_map = self._build_detection_keywords()

    def _build_subgroup_cache(self) -> Dict[str, tuple]:
        """하위 그룹 코드로 빠르게 접근할 수 있는 캐시 생성"""
        cache = {}
        for grade_key in self.GRADES:
            grade_data = self.config.get(grade_key, {})
            for key, value in grade_data.items():
                # 하위 그룹은 dict이고 prompt_template을 가짐
                if isinstance(value, dict) and 'prompt_template' in value:
                    cache[key] = (grade_key, value)
        return cache

    def _build_business_mapping(self) -> Dict[str, str]:
        """개별 업종명 → 하위 그룹 코드 매핑"""
        mapping = {}
        for subgroup_key, (grade_key, subgroup_data) in self._subgroup_cache.items():
            businesses = subgroup_data.get('businesses', [])
            for business in businesses:
                # 업종명 정규화 (소문자, 공백 제거)
                normalized = business.lower().replace(' ', '_').replace('/', '_')
                mapping[normalized] = subgroup_key
                # 원본도 추가
                mapping[business.lower()] = subgroup_key
        return mapping

    def get_industry(self, industry_code: str) -> Optional[Dict]:
        """
        업종 설정 가져오기 (v3.0.0 호환)

        Args:
            industry_code: 하위 그룹 코드 (s1_hot_cooking, a1_beauty 등)
                          또는 레거시 코드 (cafe, gym 등)

        Returns:
            Dict: 업종 설정 또는 None
        """
        # 1. 새 구조에서 하위 그룹 코드로 직접 찾기
        if industry_code in self._subgroup_cache:
            return self._subgroup_cache[industry_code][1]

        # 2. 레거시 코드 호환 (cafe → s3_emotional 등)
        legacy_mapping = self._get_legacy_mapping()
        if industry_code in legacy_mapping:
            mapped_code = legacy_mapping[industry_code]
            if mapped_code in self._subgroup_cache:
                return self._subgroup_cache[mapped_code][1]

        # 3. 개별 업종명으로 찾기
        normalized_code = industry_code.lower().replace(' ', '_')
        if normalized_code in self._business_to_subgroup:
            subgroup_code = self._business_to_subgroup[normalized_code]
            return self._subgroup_cache[subgroup_code][1]

        # 4. 없으면 general (s4_neat_variety 또는 기본값)
        return self._subgroup_cache.get('s4_neat_variety')

    def _get_legacy_mapping(self) -> Dict[str, str]:
        """레거시 업종 코드 → 신규 하위 그룹 코드 매핑"""
        return {
            # S등급
            "cafe": "s3_emotional",
            "bakery": "s3_emotional",
            "restaurant": "s1_hot_cooking",

            # A등급
            "gym": "a2_wellness",
            "hair_salon": "a1_beauty",
            "nail_salon": "a1_beauty",
            "flower_shop": "a4_delicate_care",
            "clothing_store": "a3_fashion",

            # C등급
            "laundry": "a4_delicate_care",  # 세탁소는 A4로 이동

            # 기본값
            "general": "s4_neat_variety"
        }

    def get_all_industries(self) -> Dict[str, Dict]:
        """모든 하위 그룹 설정 반환"""
        return {k: v for k, (_, v) in self._subgroup_cache.items()}

    def get_all_subgroups(self) -> List[str]:
        """사용 가능한 하위 그룹 코드 리스트"""
        return list(self._subgroup_cache.keys())

    def get_industry_names(self) -> List[str]:
        """사용 가능한 하위 그룹 코드 리스트 (레거시 호환)"""
        return self.get_all_subgroups()

    def get_grade_info(self, grade_key: str) -> Optional[Dict]:
        """등급 정보 가져오기 (core_strategy, characteristics 등)"""
        grade_data = self.config.get(grade_key, {})
        if not grade_data:
            return None
        return {
            'name': grade_data.get('name', ''),
            'name_ko': grade_data.get('name_ko', ''),
            'characteristics': grade_data.get('characteristics', ''),
            'core_strategy': grade_data.get('core_strategy', ''),
            'total_businesses': grade_data.get('total_businesses', 0)
        }

    def detect_industry(self, user_input: str) -> str:
        """
        사용자 입력에서 업종 자동 감지 (v3.0.0)

        YAML의 keywords + korean_keywords 필드 활용

        Args:
            user_input: 사용자 입력 텍스트

        Returns:
            str: 감지된 하위 그룹 코드 또는 "s4_neat_variety" (기본값)
        """
        user_input_lower = user_input.lower()

        # 초기화 시 생성된 키워드 캐시 활용
        scores = {}
        for subgroup_code, keywords in self._keyword_map.items():
            score = sum(1 for keyword in keywords if keyword in user_input_lower)
            if score > 0:
                scores[subgroup_code] = score

        # 가장 높은 점수의 하위 그룹 반환
        if scores:
            return max(scores.items(), key=lambda x: x[1])[0]

        return "s4_neat_variety"  # 기본값

    def _build_detection_keywords(self) -> Dict[str, List[str]]:
        """
        감지용 키워드 맵 구축

        YAML의 korean_keywords 필드를 직접 활용 (하드코딩 제거)
        """
        keyword_map = {}

        for subgroup_code, (grade_key, subgroup_data) in self._subgroup_cache.items():
            keywords = []

            # 1. YAML의 keywords 필드 (영어)
            yaml_keywords = subgroup_data.get('keywords', [])
            keywords.extend([kw.lower() for kw in yaml_keywords])

            # 2. YAML의 korean_keywords 필드 (한글) - 직접 로드
            korean_keywords = subgroup_data.get('korean_keywords', [])
            keywords.extend(korean_keywords)

            # 3. businesses 필드에서 추출
            businesses = subgroup_data.get('businesses', [])
            for business in businesses:
                words = business.lower().replace('/', ' ').split()
                keywords.extend(words)

            keyword_map[subgroup_code] = list(set(keywords))

        return keyword_map
```

#### 4.1.2 PromptGenerator 클래스 수정

```python
class PromptGenerator:
    """통합 프롬프트 생성기 (v3.0.0 호환)"""

    def __init__(self, config_path: Optional[str] = None):
        self.loader = IndustryConfigLoader(config_path)

    def generate(
        self,
        industry: str,  # 하위 그룹 코드 또는 레거시 코드
        user_input: Dict,
        composition: Optional[str] = None,
        apply_weights: bool = False,
        weights: Optional[Dict[str, float]] = None
    ) -> Dict[str, str]:
        """
        완전한 프롬프트 생성 (Positive + Negative, 기존과 동일)

        Args:
            industry: 업종 코드 (cafe, gym 등)
            user_input: 사용자 입력
                {
                    "style": "realistic",  # realistic, semi_realistic, anime
                    "product": "strawberry latte",
                    "theme": "warm",
                    "mood": "cozy",
                    "time": "morning"
                }
            composition: 구도 타입 (overhead, 45_degree 등)
            apply_weights: 가중치 적용 여부
            weights: 가중치 딕셔너리 {"keyword": 1.3}

        Returns:
            Dict: {
                "positive": "...",
                "negative": "...",
                "style": "...",
                "structure": {...}  # 디버깅용
            }
        """

        style = user_input.get("style", "realistic")
        if not StyleRouter.is_valid_style(style):
            style = "realistic"

        # 업종 설정 로드 (v3.0.0 호환)
        industry_config = self.loader.get_industry(industry)
        if not industry_config:
            # fallback: 기본값 사용
            industry_config = self.loader.get_industry("s4_neat_variety")

        # 나머지 로직은 기존과 동일...
        builder = HybridPromptBuilder(industry_config)
        structure = builder.build_from_user_input(user_input, composition)

        # ... (기존 코드 유지)
```

---

### 4.2 prompt_manager.py / prompt_manager_sdxl.py 수정

#### 4.2.1 _detect_industry 메서드 수정

```python
def _detect_industry(self, user_input: str) -> str:
    """
    사용자 입력에서 업종 자동 감지 (v3.0.0)

    Returns:
        str: 하위 그룹 코드 (s1_hot_cooking, a1_beauty 등)
    """
    if industry_config is None:
        return "s4_neat_variety"

    return industry_config.detect_industry(user_input)
```

#### 4.2.2 _get_industry_reference_keywords 메서드 수정

```python
def _get_industry_reference_keywords(self, industry: str) -> str:
    """
    YAML에서 업종별 참고 키워드 추출 (v3.0.0 호환)

    Args:
        industry: 하위 그룹 코드 (s1_hot_cooking, a1_beauty 등)

    Returns:
        str: 참고용 키워드 문자열
    """
    try:
        if industry_config is None:
            return "No reference keywords available."

        industry_data = industry_config.get_industry(industry)
        if not industry_data or "prompt_template" not in industry_data:
            return "No reference keywords available."

        template = industry_data["prompt_template"]
        keywords = []

        # visual_core 추가 (신규 필드)
        if "visual_core" in industry_data:
            keywords.append(f"Visual Core: {industry_data['visual_core']}")

        # 주요 키워드 카테고리 추출
        if "lighting_phrases" in template:
            keywords.append(f"Lighting: {', '.join(template['lighting_phrases'][:3])}")
        if "composition_keywords" in template:
            keywords.append(f"Composition: {', '.join(template['composition_keywords'][:3])}")
        if "color_phrases" in template:
            keywords.append(f"Colors: {', '.join(template['color_phrases'][:3])}")
        if "style_keywords" in template:
            keywords.append(f"Style: {', '.join(template['style_keywords'][:3])}")
        if "details_keywords" in template:
            keywords.append(f"Details: {', '.join(template['details_keywords'][:3])}")

        if not keywords:
            return "No reference keywords available."

        return "\n".join(keywords)

    except Exception as e:
        print(f"⚠️ 참고 키워드 로드 실패: {e}")
        return "No reference keywords available."
```

---

### 4.3 prompt_templates.py / prompt_templates_sdxl.py

#### 변경 불필요
- `HybridPromptBuilder`와 `PromptStructure`는 `prompt_template` 딕셔너리만 받으면 됨
- 신규 YAML에서도 `prompt_template` 구조는 동일하게 유지됨
- `required_layers`, `keywords`, `negative_keywords` 등도 동일한 위치에 존재

---

### 4.4 style_router.py

#### 변경 불필요
- 스타일 라우팅은 업종과 독립적으로 동작
- `realistic`, `semi_realistic`, `anime` 스타일은 그대로 유지

---

## 5. 신규 기능 추가 제안

### 5.1 등급별 전략 적용

신규 YAML에는 등급별 `core_strategy`와 `characteristics`가 포함되어 있습니다.
이를 활용하여 프롬프트 생성 시 등급별 차별화된 전략을 적용할 수 있습니다.

```python
class GradeAwarePromptGenerator:
    """등급별 전략을 적용하는 프롬프트 생성기"""

    GRADE_STRATEGIES = {
        "s_grade": {
            "emphasis": ["visual_appeal", "taste_visualization", "high_resolution"],
            "style_preference": "realistic",
            "detail_level": "very_high"
        },
        "a_grade": {
            "emphasis": ["transformation", "before_after", "self_care"],
            "style_preference": "realistic",
            "detail_level": "high"
        },
        "b_grade": {
            "emphasis": ["space_experience", "interior", "wide_angle"],
            "style_preference": "realistic",
            "detail_level": "medium"
        },
        "c_grade": {
            "emphasis": ["trust", "professionalism", "clean_design"],
            "style_preference": "realistic",
            "detail_level": "medium"
        },
        "d_grade": {
            "emphasis": ["information", "product_features", "clarity"],
            "style_preference": "realistic",
            "detail_level": "low"
        },
        "e_grade": {
            "emphasis": ["accessibility", "straightforward", "location"],
            "style_preference": "realistic",
            "detail_level": "minimal"
        }
    }

    def apply_grade_strategy(self, prompt_structure: PromptStructure, grade: str):
        """등급별 전략 적용"""
        strategy = self.GRADE_STRATEGIES.get(grade, {})
        # 전략에 따른 프롬프트 조정 로직...
```

### 5.2 visual_core 활용

각 하위 그룹에 `visual_core` 필드가 추가되었습니다.
이를 프롬프트 생성 시 핵심 키워드로 활용할 수 있습니다.

```python
def _build_subject_phrase_with_visual_core(self, user_input: Dict) -> str:
    """visual_core를 활용한 Subject 생성"""
    visual_core = self.industry_data.get('visual_core', '')

    if visual_core:
        # visual_core의 핵심 키워드 추출
        core_keywords = visual_core.split(', ')[:3]
        # 프롬프트에 반영
        ...
```

### 5.3 businesses 배열 활용

`businesses` 배열을 활용하여 더 정확한 업종 감지가 가능합니다.

```python
def detect_industry_precise(self, user_input: str) -> str:
    """정밀 업종 감지 - businesses 배열 활용"""
    # 개별 업종명 매칭 시도
    for business_name in all_businesses:
        if business_name.lower() in user_input.lower():
            return self._business_to_subgroup[business_name.lower()]

    # 키워드 기반 감지로 fallback
    return self.detect_industry(user_input)
```

---

## 6. 마이그레이션 계획

### 6.1 단계별 진행

| 단계 | 작업 내용 | 예상 영향 |
|------|----------|----------|
| 1 | `config_loader.py` 수정 | 핵심 변경, 다른 모듈에 영향 |
| 2 | `prompt_manager.py` 수정 | 업종 감지 로직 개선 |
| 3 | `prompt_manager_sdxl.py` 수정 | SDXL용 동일 수정 |
| 4 | 테스트 코드 작성 | 레거시 호환성 검증 |
| 5 | industries.yaml 교체 | 신규 파일로 대체 |
| 6 | 통합 테스트 | 전체 파이프라인 검증 |

### 6.2 레거시 호환성

- 기존 코드에서 `"cafe"`, `"gym"` 등의 레거시 코드를 사용하는 경우
- `_get_legacy_mapping()` 메서드를 통해 자동으로 신규 코드로 매핑
- 점진적으로 신규 코드로 전환 가능

### 6.3 테스트 케이스

```python
# 레거시 호환성 테스트
def test_legacy_industry_codes():
    loader = IndustryConfigLoader()

    # 레거시 코드가 신규 코드로 매핑되는지 확인
    assert loader.get_industry("cafe") is not None
    assert loader.get_industry("gym") is not None
    assert loader.get_industry("bakery") is not None

    # 신규 코드 직접 접근
    assert loader.get_industry("s1_hot_cooking") is not None
    assert loader.get_industry("a1_beauty") is not None

# 업종 감지 테스트
def test_industry_detection():
    loader = IndustryConfigLoader()

    # 한글 입력 테스트
    assert loader.detect_industry("삼겹살 맛집 홍보") == "s1_hot_cooking"
    assert loader.detect_industry("카페 신메뉴 딸기라떼") == "s3_emotional"
    assert loader.detect_industry("헬스장 광고") == "a2_wellness"
    assert loader.detect_industry("미용실 헤어스타일") == "a1_beauty"
```

---

## 7. YAML 파일 개선 제안

### 7.1 한글 키워드 추가 ✅ (완료)

~~현재 `keywords` 필드에는 영어 키워드만 포함되어 있습니다.
업종 감지 정확도 향상을 위해 한글 키워드를 추가하는 것을 권장합니다.~~

**2026-01-19 업데이트:** `industries.yaml`에 `korean_keywords` 필드가 추가되었습니다.

```yaml
s1_hot_cooking:
  keywords:
    - grilled
    - sizzling
    - hot
    - juicy
    # ...

  korean_keywords:
    - 삼겹살
    - 고기
    - 구이
    - 소고기
    - 돼지고기
    - 곱창
    - 치킨
    - 피자
    - 버거
    # ...
```

이제 `IndustryConfigLoader._build_detection_keywords()` 메서드에서 YAML의 `korean_keywords` 필드를 직접 로드하여 사용합니다. 하드코딩된 `_get_korean_keywords()` 메서드는 더 이상 필요하지 않습니다.

### 7.2 aliases 필드 추가

동의어/별칭 처리를 위한 필드 추가를 권장합니다.

```yaml
s3_emotional:
  aliases:
    - cafe
    - coffee_shop
    - bakery
    - dessert
```

---

## 8. 결론

### 8.1 변경 요약

| 파일 | 변경 수준 | 주요 변경 사항 |
|------|----------|---------------|
| config_loader.py | **대규모** | 계층 구조 탐색, 캐시 시스템, 레거시 호환 |
| prompt_manager.py | 중간 | 업종 감지 로직 위임 |
| prompt_manager_sdxl.py | 중간 | 업종 감지 로직 위임 |
| prompt_templates.py | 없음 | 변경 불필요 |
| prompt_templates_sdxl.py | 없음 | 변경 불필요 |
| style_router.py | 없음 | 변경 불필요 |

### 8.2 예상 효과

1. **업종 커버리지 확대**: 10개 → 247개 업종 지원
2. **정밀한 프롬프트 생성**: 세분화된 하위 그룹별 템플릿 적용
3. **등급별 전략 적용**: S~E 등급별 차별화된 광고 전략 구현 가능
4. **레거시 호환성**: 기존 코드 수정 없이 점진적 마이그레이션 가능

### 8.3 후속 작업

1. 코드 구현 및 단위 테스트
2. ~~한글 키워드 맵 YAML 이전~~ ✅ 완료 (2026-01-19)
3. 등급별 전략 로직 구현
4. 통합 테스트 및 성능 검증
5. 문서화 및 배포

---

**문서 끝**
