# 백엔드 리팩토링 계획서

**작성일**: 2026-01-15
**담당**: 백엔드 로직 (진수경)
**버전**: 1.0
**목적**: RAG 기반 챗봇 아키텍처에 맞춘 백엔드 코드 리팩토링 계획

---

## 목차

1. [현재 상태 분석](#1-현재-상태-분석)
2. [리팩토링 목표](#2-리팩토링-목표)
3. [아키텍처 변경 사항](#3-아키텍처-변경-사항)
4. [단계별 리팩토링 계획](#4-단계별-리팩토링-계획)
5. [코드 구현 가이드](#5-코드-구현-가이드)
6. [테스트 계획](#6-테스트-계획)
7. [마이그레이션 전략](#7-마이그레이션-전략)

---

## 1. 현재 상태 분석

### 1.1 기존 코드 현황

#### 구현된 파일

| 파일 | 상태 | 주요 기능 |
|-----|------|----------|
| `models.py` | ✅ 완성 | User, ChatSession, ChatHistory, GenerationHistory, ImageMatching |
| `process_db.py` | ✅ 완성 | DB CRUD 함수들 |
| `services.py` | ⚠️ 부분 구현 | 광고 생성 파이프라인, 챗봇 메시지 처리 (기본) |
| `task.py` | ✅ 완성 | Task 상태 관리 (in-memory) |
| `routers/chat.py` | ⚠️ 부분 구현 | 챗봇 엔드포인트 (기본) |
| `chatbot.py` | ❌ 미구현 | RAG 챗봇 핵심 로직 |

#### 구현된 기능

**✅ 완성된 기능**:
1. 사용자 인증 (회원가입, 로그인, JWT)
2. 광고 생성 파이프라인
   - `ingest_user_message()`: 입력 수집/저장
   - `generate_contents()`: 광고 생성 (텍스트/이미지)
   - `persist_generation_result()`: DB 저장
   - `handle_generate_pipeline()`: 통합 파이프라인
3. Task 기반 진행률 관리
4. 세션 관리 (게스트 지원)

**⚠️ 부분 구현된 기능**:
1. 챗봇 메시지 처리
   - `handle_chat_message()`: 기본 골격만 존재
   - RAG 챗봇 로직 없음 (chatbot.py 미구현)
2. 챗봇 기반 광고 생성
   - `handle_chat_generate()`: 워크플로우 검증 후 생성
   - chatbot.py 의존성 (미구현)

**❌ 미구현된 기능**:
1. RAG 챗봇 핵심 로직 (chatbot.py)
   - 의도 분석
   - VectorDB 검색 (PostgreSQL + 정적 파일)
   - 워크플로우 상태 관리
   - LLM 호출 및 응답 생성
2. 수정/컨펌 플로우
   - `handle_chat_revise()`: 광고 수정
   - `handle_chat_confirm()`: 최종 확정
3. pgvector 통합 (선택사항)

### 1.2 현재 아키텍처의 문제점

#### 문제 1: RAG 챗봇 로직 부재

**현재**:
```python
# services.py: handle_chat_message()
async def handle_chat_message(...):
    # 1. 세션 확보
    session_key = ensure_chat_session(db, session_id, user_id)

    # 2. 이미지 처리
    if image:
        image_data = await save_uploaded_image(...)

    # 3. 챗봇 처리
    chatbot = get_chatbot()  # ❌ chatbot.py 미구현
    result = await chatbot.process_message(...)  # ❌ 동작 안 함

    return response
```

**문제점**:
- `chatbot.py`가 없어서 `get_chatbot()` 호출 불가
- RAG 파이프라인 (의도 분석, VectorDB 검색) 없음
- Intent별 처리 분기 없음 (생성/수정 vs 상담)

#### 문제 2: Intent별 처리 분기 미구현

**현재**:
- 생성/수정 intent: 백엔드에서 정보 수집 시도 (불필요)
- 상담 intent: 적절한 LLM 응답 생성 로직 없음

**문제점**:
- **생성/수정 intent는 바로 생성 파이프라인으로 넘겨야 함** (생성 파이프라인에서 이미 LLM으로 정보 추출)
- **상담 intent만 백엔드 RAG 챗봇에서 LLM 호출 필요**

#### 문제 3: VectorDB 검색 전략 없음

**현재**:
- PostgreSQL에서 단순 시간순 조회만 가능
- 유사도 기반 검색 없음 (pgvector 미사용)
- 정적 파일 VectorDB 통합 없음 (팀원 협업 미정의)

#### 문제 4: 수정/컨펌 플로우 없음

**현재**:
- 광고 생성 후 수정 불가 (새로 생성만 가능)
- 최종 확정 개념 없음
- 생성 이력 관리 미흡 (revision 관계 없음)

### 1.3 리팩토링 필요성

**핵심 요구사항**:
1. **Intent 분석**: 생성/수정/상담 의도 구분 (LLM 1회 호출)
2. **Intent별 처리 분기**:
   - 생성/수정: PostgreSQL 검색 → 바로 생성 파이프라인 호출 (백엔드에서 LLM 호출 없음)
   - 상담: PostgreSQL + 정적 파일 검색 → LLM 호출 → 상담 응답
3. **이중 VectorDB 전략**: PostgreSQL (대화 히스토리) + 정적 파일 (상담 지식)
4. **수정/컨펌 플로우**: 생성 → 수정 → 확정 사이클

**리팩토링 방향**:
- `chatbot.py` 신규 구현 (Intent 분석 + Intent별 처리 분기)
- `services.py` 보완 (수정/컨펌 서비스 추가, 생성 파이프라인 통합)
- `models.py` 확장 (GenerationHistory에 revision 필드 추가)
- `process_db.py` 확장 (벡터 검색 함수 추가)

---

## 2. 리팩토링 목표

### 2.1 기능적 목표

1. **RAG 챗봇 구현**
   - 사용자 의도 자동 분석
   - 대화 히스토리 기반 맥락 이해
   - 지식베이스 참조 응답 생성

2. **워크플로우 관리**
   - 광고 생성에 필요한 정보 수집 추적
   - 누락 정보 자동 질문
   - 생성 준비 완료 판단

3. **수정/컨펌 플로우**
   - 생성된 광고 수정 요청 처리
   - 수정 이력 추적 (버전 관리)
   - 최종 확정 기능

4. **VectorDB 통합**
   - PostgreSQL 대화/생성 히스토리 검색
   - 정적 파일 VectorDB 연동 (팀원 협업)

### 2.2 비기능적 목표

1. **코드 품질**
   - 레이어 분리 (Presentation, Service, Business, Data)
   - 단일 책임 원칙 (SRP)
   - 의존성 주입 (DI)

2. **확장성**
   - 새로운 의도 추가 용이
   - VectorDB 교체 가능 (pgvector, ChromaDB 등)
   - LLM 교체 가능 (GPT, Claude, Gemini 등)

3. **테스트 가능성**
   - 각 레이어 독립 테스트
   - Mock 객체 활용
   - 통합 테스트 지원

4. **성능**
   - LLM 호출 최소화 (캐싱)
   - DB 쿼리 최적화 (인덱스)
   - 비동기 처리 (async/await)

---

## 3. 아키텍처 변경 사항

### 3.1 새로운 레이어 구조

```
┌───────────────────────────────────────────────────────┐
│ Presentation Layer (routers/)                         │
│  - FastAPI 엔드포인트                                  │
│  - 요청 검증 (Pydantic schemas)                        │
│  - 인증/인가 (JWT)                                     │
└─────────────────────┬─────────────────────────────────┘
                      │
┌─────────────────────▼─────────────────────────────────┐
│ Service Layer (services.py)                           │
│  - 비즈니스 로직 오케스트레이션                         │
│  - 트랜잭션 관리                                        │
│  - 에러 핸들링                                          │
└─────────────────────┬─────────────────────────────────┘
                      │
┌─────────────────────▼─────────────────────────────────┐
│ Business Logic Layer (chatbot.py)                     │
│  ┌─────────────────────────────────────────────────┐ │
│  │ RAGChatbot (메인 클래스)                        │ │
│  │  - process_message()                            │ │
│  │    → Intent 분석 후 분기 처리                    │ │
│  │    → 생성/수정: 생성 파이프라인 호출              │ │
│  │    → 상담: LLM 응답 생성                         │ │
│  └─────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────┐ │
│  │ ConversationManager (대화 관리)                 │ │
│  │  - add_message()                                │ │
│  │  - get_recent_messages()                        │ │
│  │  - get_generation_history()                     │ │
│  │  - search_similar_messages()                    │ │
│  └─────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────┐ │
│  │ LLMOrchestrator (LLM 호출 관리)                 │ │
│  │  - analyze_intent()                             │ │
│  │    (모든 경우에 사용: 생성/수정/상담 구분)         │ │
│  │  - generate_consulting_response()               │ │
│  │    (상담 intent에만 사용)                        │ │
│  └─────────────────────────────────────────────────┘ │
└─────────────────────┬─────────────────────────────────┘
                      │
┌─────────────────────▼─────────────────────────────────┐
│ Data Access Layer (process_db.py, models.py)          │
│  - DB CRUD 함수                                        │
│  - SQLAlchemy 모델                                     │
│  - 벡터 검색 함수                                       │
└───────────────────────────────────────────────────────┘
```

### 3.2 새로운 파일 구조

```
src/backend/
├── __init__.py
├── models.py                    # ✅ 완성 (확장 필요)
├── schemas.py                   # ✅ 완성 (확장 필요)
├── process_db.py                # ✅ 완성 (확장 필요)
├── services.py                  # ⚠️ 보완 필요
├── task.py                      # ✅ 완성
├── chatbot.py                   # ❌ 신규 구현 필요 ⭐
│   ├── RAGChatbot               # Intent 분석 + 분기 처리
│   ├── ConversationManager      # PostgreSQL 대화 관리
│   └── LLMOrchestrator          # Intent 분석 + 상담 응답 생성
└── routers/
    ├── __init__.py
    ├── auth.py                  # ✅ 완성
    ├── chat.py                  # ⚠️ 보완 필요
    └── generate.py              # ✅ 완성
```

### 3.3 DB 스키마 변경

#### 추가할 컬럼 (GenerationHistory)

```sql
ALTER TABLE generation_history
ADD COLUMN is_confirmed BOOLEAN DEFAULT FALSE;  -- 최종 확정 여부

ALTER TABLE generation_history
ADD COLUMN revision_of_id INTEGER;  -- 이전 버전 ID (self FK)

ALTER TABLE generation_history
ADD COLUMN revision_number INTEGER DEFAULT 0;  -- 수정 버전 번호

ALTER TABLE generation_history
ADD CONSTRAINT fk_revision_of
FOREIGN KEY (revision_of_id) REFERENCES generation_history(id);
```

#### pgvector 확장 (선택사항)

```sql
CREATE EXTENSION IF NOT EXISTS vector;

ALTER TABLE chat_history
ADD COLUMN embedding vector(1536);  -- OpenAI embedding

CREATE INDEX idx_chat_history_embedding
ON chat_history
USING ivfflat (embedding vector_cosine_ops);
```

---

## 4. 단계별 리팩토링 계획

### 단계 1: 기반 구조 구축 (1-2일)

#### 1.1 chatbot.py 스켈레톤 생성

**목표**: RAG 챗봇의 기본 클래스 구조 생성

**작업 항목**:
1. `chatbot.py` 파일 생성
2. 주요 클래스 정의 (RAGChatbot, ConversationManager 등)
3. 인터페이스 메서드 정의 (구현은 빈 함수로)

**우선순위**: HIGH

**코드 예시**:
```python
# src/backend/chatbot.py

from typing import Optional, List, Dict
from sqlalchemy.orm import Session


class ConversationManager:
    """대화 히스토리 관리"""

    def add_message(
        self,
        db: Session,
        session_id: str,
        role: str,
        content: str,
        image_id: Optional[int] = None
    ) -> int:
        """메시지 저장 (PostgreSQL)"""
        # TODO: 구현
        pass

    def get_recent_messages(
        self,
        db: Session,
        session_id: str,
        limit: int = 10
    ) -> List[Dict]:
        """최근 대화 조회"""
        # TODO: 구현
        pass

    def search_similar_messages(
        self,
        db: Session,
        query: str,
        session_id: Optional[str] = None,
        limit: int = 5
    ) -> List[Dict]:
        """유사 대화 검색 (pgvector)"""
        # TODO: 구현
        pass


class LLMOrchestrator:
    """LLM 호출 관리"""

    def __init__(self, api_key: str, model: str = "gpt-4o-mini"):
        self.api_key = api_key
        self.model = model

    async def analyze_intent(self, user_message: str, context: Dict) -> Dict:
        """의도 분석 (생성/수정/상담 구분)"""
        # TODO: 구현
        pass

    async def generate_consulting_response(
        self,
        user_message: str,
        context: Dict
    ) -> str:
        """상담 응답 생성 (상담 intent에만 사용)"""
        # TODO: 구현
        pass


class RAGChatbot:
    """RAG 기반 챗봇 메인 클래스"""

    def __init__(
        self,
        llm_orchestrator: LLMOrchestrator,
        conversation_manager: ConversationManager
    ):
        self.llm = llm_orchestrator
        self.conv = conversation_manager

    async def process_message(
        self,
        db: Session,
        session_id: str,
        user_message: str,
        image_id: Optional[int] = None
    ) -> Dict:
        """
        메시지 처리 (RAG 파이프라인)

        플로우:
        1. Intent 분석 (LLM 1회 호출)
        2. Intent별 분기:
           - 생성/수정: PostgreSQL 검색 → 생성 파이프라인 호출
           - 상담: PostgreSQL + 정적파일 검색 → LLM 응답 생성
        """
        # TODO: 구현
        pass


# 싱글톤 인스턴스
_chatbot_instance: Optional[RAGChatbot] = None

def get_chatbot() -> RAGChatbot:
    """챗봇 인스턴스 반환 (싱글톤)"""
    global _chatbot_instance
    if _chatbot_instance is None:
        from src.utils.config import settings
        llm = LLMOrchestrator(api_key=settings.OPENAI_API_KEY)
        conv = ConversationManager()
        _chatbot_instance = RAGChatbot(llm, conv)
    return _chatbot_instance
```

#### 1.2 DB 스키마 확장

**목표**: GenerationHistory에 revision 관련 컬럼 추가

**작업 항목**:
1. `models.py` 수정
2. Alembic 마이그레이션 스크립트 생성 (또는 수동 ALTER TABLE)
3. `process_db.py`에 관련 함수 추가

**우선순위**: HIGH

**코드 예시**:
```python
# src/backend/models.py

from sqlalchemy import Column, Integer, Boolean

class GenerationHistory(Base):
    __tablename__ = "generation_history"

    # 기존 필드...

    # 추가할 필드
    is_confirmed = Column(Boolean, default=False)
    revision_of_id = Column(
        Integer,
        ForeignKey('generation_history.id'),
        nullable=True
    )
    revision_number = Column(Integer, default=0)

    # 관계 정의
    revision_of = relationship(
        "GenerationHistory",
        remote_side=[id],
        backref="revisions"
    )
```

#### 1.3 스키마 확장 (schemas.py)

**목표**: 수정/컨펌 요청 스키마 추가

**작업 항목**:
1. `ReviseRequest` 스키마
2. `ConfirmRequest` 스키마
3. `WorkflowStateResponse` 스키마

**우선순위**: MEDIUM

**코드 예시**:
```python
# src/backend/schemas.py

from pydantic import BaseModel
from typing import Optional, List

class ReviseRequest(BaseModel):
    session_id: str
    revision_request: str  # "더 밝게", "텍스트 변경" 등

class ConfirmRequest(BaseModel):
    session_id: str

class WorkflowStateResponse(BaseModel):
    session_id: str
    ad_type: Optional[str]
    business_type: Optional[str]
    user_input: Optional[str]
    style: Optional[str]
    aspect_ratio: Optional[str]
    is_complete: bool
    missing_info: List[str]
```

---

### 단계 2: RAG 챗봇 핵심 로직 구현 (3-4일)

#### 2.1 ConversationManager 구현

**목표**: PostgreSQL 대화 히스토리 관리

**작업 항목**:
1. `add_message()` 구현
2. `get_recent_messages()` 구현
3. `get_generation_history()` 구현 (추가)
4. `search_similar_messages()` 스텁 (pgvector는 나중에)

**우선순위**: HIGH

**코드 예시**:
```python
# chatbot.py: ConversationManager

from src.backend import process_db

class ConversationManager:
    def add_message(
        self,
        db: Session,
        session_id: str,
        role: str,
        content: str,
        image_id: Optional[int] = None
    ) -> int:
        """메시지 저장 (PostgreSQL)"""
        chat_row = process_db.save_chat_message(
            db,
            {
                "session_id": session_id,
                "role": role,
                "content": content,
                "image_id": image_id,
            }
        )
        return chat_row.id

    def get_recent_messages(
        self,
        db: Session,
        session_id: str,
        limit: int = 10
    ) -> List[Dict]:
        """최근 대화 조회"""
        messages = process_db.get_chat_history_by_session(
            db, session_id, limit
        )
        return [
            {
                "role": msg.role,
                "content": msg.content,
                "image_id": msg.image_id,
                "timestamp": msg.created_at.isoformat()
            }
            for msg in messages
        ]

    def get_generation_history(
        self,
        db: Session,
        session_id: str,
        limit: int = 5
    ) -> List[Dict]:
        """생성 이력 조회"""
        generations = process_db.get_generation_history_by_session(
            db, session_id, limit
        )
        return [
            {
                "content_type": gen.content_type,
                "output_text": gen.output_text,
                "prompt": gen.prompt,
                "style": gen.style,
                "industry": gen.industry,
                "timestamp": gen.created_at.isoformat()
            }
            for gen in generations
        ]

    def search_similar_messages(
        self,
        db: Session,
        query: str,
        session_id: Optional[str] = None,
        limit: int = 5
    ) -> List[Dict]:
        """유사 대화 검색 (pgvector)"""
        # TODO: pgvector 구현 (나중에)
        # 현재는 최근 메시지 반환
        return self.get_recent_messages(db, session_id, limit)
```

#### 2.2 LLMOrchestrator 구현

**목표**: GPT-4o-mini 호출 (Intent 분석 + 상담 응답 생성)

**작업 항목**:
1. `analyze_intent()` 구현 (의도 분석)
2. `generate_consulting_response()` 구현 (상담 응답만)
3. 프롬프트 템플릿 관리

**우선순위**: HIGH

**코드 예시**:
```python
# chatbot.py: LLMOrchestrator

import openai
import json

class LLMOrchestrator:
    def __init__(self, api_key: str, model: str = "gpt-4o-mini"):
        self.api_key = api_key
        self.model = model
        openai.api_key = api_key

    async def analyze_intent(
        self,
        user_message: str,
        context: Dict
    ) -> Dict:
        """의도 분석 (생성/수정/상담 구분)"""
        system_prompt = """
당신은 광고 제작 어시스턴트입니다. 사용자 메시지를 분석하여 의도를 파악하세요.

의도 분류:
- generation: 새로운 광고를 만들고 싶어하는 경우
- modification: 기존 광고를 수정하고 싶어하는 경우
- consulting: 광고 제작 방법이나 조언을 구하는 경우

JSON 형식으로 응답:
{
  "intent": "generation|modification|consulting",
  "confidence": 0.0-1.0
}
"""
        user_prompt = f"사용자 메시지: {user_message}"

        response = await openai.ChatCompletion.acreate(
            model=self.model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,
        )

        content = response.choices[0].message.content
        try:
            result = json.loads(content)
            return result
        except json.JSONDecodeError:
            return {"intent": "consulting", "confidence": 0.5}

    async def generate_consulting_response(
        self,
        user_message: str,
        context: Dict
    ) -> str:
        """상담 응답 생성 (상담 intent에만 사용)"""
        system_prompt = self._build_consulting_system_prompt()
        user_prompt = self._build_consulting_user_prompt(user_message, context)

        response = await openai.ChatCompletion.acreate(
            model=self.model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.7,
        )

        return response.choices[0].message.content

    def _build_consulting_system_prompt(self) -> str:
        """상담용 시스템 프롬프트"""
        return """
당신은 광고 제작 전문 상담사입니다. 사용자의 질문에 대해 친절하고 전문적으로 답변하세요.

답변 시 고려사항:
1. 사용자의 과거 대화 맥락을 참고하세요.
2. 이전 생성 이력이 있다면 개인화된 조언을 제공하세요.
3. 지식베이스의 정보를 활용하되, 자연스럽게 통합하세요.
4. 구체적이고 실행 가능한 조언을 제공하세요.
"""

    def _build_consulting_user_prompt(
        self,
        user_message: str,
        context: Dict
    ) -> str:
        """상담용 사용자 프롬프트"""
        recent_conversations = context.get("recent_conversations", [])
        generation_history = context.get("generation_history", [])
        knowledge_base = context.get("knowledge_base", [])

        conv_str = "\n".join([
            f"{msg['role']}: {msg['content']}"
            for msg in recent_conversations[-5:]
        ])

        kb_str = "\n".join([
            f"- {doc['content'][:200]}..."
            for doc in knowledge_base[:3]
        ])

        return f"""
사용자 질문: "{user_message}"

최근 대화 맥락:
{conv_str}

이전 생성 이력:
{json.dumps(generation_history[:2], ensure_ascii=False, indent=2)}

관련 지식베이스:
{kb_str}
"""
```

#### 2.3 RAGChatbot.process_message() 구현

**목표**: RAG 파이프라인 통합 (Intent별 분기 처리)

**작업 항목**:
1. 의도 분석 호출
2. VectorDB 검색 (PostgreSQL + 정적 파일)
3. Intent별 분기:
   - **생성/수정**: 생성 파이프라인 호출 (LLM 호출 없음)
   - **상담**: LLM 응답 생성
4. 대화 저장

**우선순위**: HIGH

**코드 예시**:
```python
# chatbot.py: RAGChatbot.process_message()

class RAGChatbot:
    async def process_message(
        self,
        db: Session,
        session_id: str,
        user_message: str,
        image_id: Optional[int] = None
    ) -> Dict:
        """
        메시지 처리 (RAG 파이프라인)

        플로우:
        1. Intent 분석 (LLM 1회 호출)
        2. Intent별 분기:
           - 생성/수정: PostgreSQL 검색 → 생성 파이프라인 호출
           - 상담: PostgreSQL + 정적파일 검색 → LLM 응답 생성
        """

        # 1. 사용자 메시지 저장
        self.conv.add_message(
            db, session_id, "user", user_message, image_id
        )

        # 2. PostgreSQL 검색 (모든 경우에 필요)
        recent_conversations = self.conv.get_recent_messages(
            db, session_id, limit=10
        )
        generation_history = self.conv.get_generation_history(
            db, session_id, limit=5
        )

        context = {
            "recent_conversations": recent_conversations,
            "generation_history": generation_history,
        }

        # 3. 의도 분석
        intent_result = await self.llm.analyze_intent(
            user_message, context
        )
        intent = intent_result.get("intent", "consulting")

        # 4. Intent별 분기 처리
        if intent in ["generation", "modification"]:
            # 생성/수정: 바로 생성 파이프라인으로 리다이렉트
            # 생성 파이프라인에서 스타일/비율 등 정보 추출
            return {
                "intent": intent,
                "redirect_to_pipeline": True,
                "context": context
            }

        elif intent == "consulting":
            # 상담: 정적 파일 VectorDB 검색 + LLM 응답 생성
            # TODO: 정적 파일 VectorDB 검색 (팀원 협업)
            # knowledge_results = consulting_knowledge_base.search(
            #     query=user_message,
            #     category="faq",
            #     limit=3
            # )
            # context["knowledge_base"] = knowledge_results

            # LLM 호출 (상담 응답 생성)
            assistant_message = await self.llm.generate_consulting_response(
                user_message, context
            )

            # 어시스턴트 응답 저장
            self.conv.add_message(
                db, session_id, "assistant", assistant_message
            )

            return {
                "intent": "consulting",
                "assistant_message": assistant_message,
                "redirect_to_pipeline": False
            }

        else:
            # 알 수 없는 intent (기본값: 상담)
            assistant_message = "무엇을 도와드릴까요?"
            self.conv.add_message(
                db, session_id, "assistant", assistant_message
            )
            return {
                "intent": "consulting",
                "assistant_message": assistant_message,
                "redirect_to_pipeline": False
            }
```

---

### 단계 3: 수정/컨펌 플로우 구현 (2-3일)

#### 3.1 수정 요청 서비스 (services.py)

**목표**: 광고 수정 요청 처리

**작업 항목**:
1. `handle_chat_revise()` 함수 구현
2. 이전 생성 결과 조회
3. 수정 파라미터 추출 (LLM 활용)
4. 재생성 파이프라인 호출
5. revision 관계 설정

**우선순위**: MEDIUM

**코드 예시**:
```python
# services.py

async def handle_chat_revise(
    *,
    db: Session,
    session_id: str,
    user_id: Optional[int],
    revision_request: str,
    task_id: str,
):
    """
    생성된 광고 수정 요청 처리
    """
    logger.info(f"handle_chat_revise: session={session_id}, request={revision_request}")

    # 1. 최근 생성 이력 조회
    latest_generation = (
        db.query(models.GenerationHistory)
        .filter(models.GenerationHistory.session_id == session_id)
        .order_by(models.GenerationHistory.created_at.desc())
        .first()
    )

    if not latest_generation:
        raise HTTPException(
            status_code=404,
            detail="수정할 광고를 찾을 수 없습니다. 먼저 광고를 생성해주세요."
        )

    # 2. 수정 요청 파싱 (LLM 활용)
    # TODO: LLM으로 revision_request 분석
    # 예: "더 밝게" → style 변경, "텍스트 변경" → user_input 업데이트
    # 현재는 기본값 사용
    updated_params = {
        "input_text": latest_generation.input_text,
        "generation_type": latest_generation.content_type,
        "style": latest_generation.style,
        "aspect_ratio": latest_generation.aspect_ratio,
    }

    # 3. 재생성 파이프라인 호출
    result = await handle_generate_pipeline(
        db=db,
        input_text=updated_params["input_text"],
        session_id=session_id,
        user_id=user_id,
        image=None,
        task_id=task_id,
        create_task_entry=True,
        generation_type=updated_params["generation_type"],
        style=updated_params["style"],
        aspect_ratio=updated_params["aspect_ratio"],
    )

    # 4. revision 관계 설정
    new_generation = (
        db.query(models.GenerationHistory)
        .order_by(models.GenerationHistory.id.desc())
        .first()
    )

    new_generation.revision_of_id = latest_generation.id
    new_generation.revision_number = latest_generation.revision_number + 1
    db.commit()

    logger.info(f"handle_chat_revise: complete, new_id={new_generation.id}")

    return result
```

#### 3.2 컨펌 서비스 (services.py)

**목표**: 최종 광고 확정

**작업 항목**:
1. `handle_chat_confirm()` 함수 구현
2. GenerationHistory 상태 업데이트 (is_confirmed=True)
3. 워크플로우 초기화

**우선순위**: MEDIUM

**코드 예시**:
```python
# services.py

async def handle_chat_confirm(
    *,
    db: Session,
    session_id: str,
):
    """
    최종 광고 확정 처리
    """
    logger.info(f"handle_chat_confirm: session={session_id}")

    # 1. 최근 생성 이력 조회
    latest_generation = (
        db.query(models.GenerationHistory)
        .filter(models.GenerationHistory.session_id == session_id)
        .order_by(models.GenerationHistory.created_at.desc())
        .first()
    )

    if not latest_generation:
        raise HTTPException(
            status_code=404,
            detail="확정할 광고를 찾을 수 없습니다."
        )

    # 2. is_confirmed 업데이트
    latest_generation.is_confirmed = True
    db.commit()

    # 3. 워크플로우 초기화
    chatbot = get_chatbot()
    chatbot.reset_workflow(session_id)

    logger.info(f"handle_chat_confirm: confirmed, id={latest_generation.id}")

    return {
        "session_id": session_id,
        "message": "광고가 확정되었습니다.",
        "generation_id": latest_generation.id,
    }
```

#### 3.3 라우터 추가 (routers/chat.py)

**목표**: 수정/컨펌 엔드포인트 추가

**작업 항목**:
1. `POST /chat/revise` 엔드포인트
2. `POST /chat/confirm` 엔드포인트

**우선순위**: MEDIUM

**코드 예시**:
```python
# routers/chat.py

@router.post("/revise")
async def revise_content(
    background_tasks: BackgroundTasks,
    session_id: str = Form(...),
    revision_request: str = Form(...),
    db: Session = Depends(process_db.get_db),
    current_user=Depends(services.get_current_user),
):
    """
    생성된 광고 수정 요청
    """
    user_id = current_user.user_id if current_user else None
    task_id = str(uuid.uuid4())

    # 백그라운드에서 수정 실행
    background_tasks.add_task(
        services.handle_chat_revise,
        db=db,
        session_id=session_id,
        user_id=user_id,
        revision_request=revision_request,
        task_id=task_id,
    )

    return {"task_id": task_id}


@router.post("/confirm")
async def confirm_content(
    session_id: str = Form(...),
    db: Session = Depends(process_db.get_db),
    current_user=Depends(services.get_current_user),
):
    """
    최종 광고 확정
    """
    result = await services.handle_chat_confirm(
        db=db,
        session_id=session_id,
    )

    return result
```

---

### 단계 4: 정적 파일 VectorDB 통합 (2-3일)

#### 4.1 인터페이스 정의

**목표**: 팀원과 협업 인터페이스 정의

**작업 항목**:
1. `ConsultingKnowledgeBase` 인터페이스 클래스 작성
2. Mock 구현 (테스트용)
3. 팀원에게 인터페이스 공유

**우선순위**: MEDIUM

**코드 예시**:
```python
# src/backend/consulting_knowledge_base.py

from typing import List, Dict, Optional
from abc import ABC, abstractmethod


class ConsultingKnowledgeBase(ABC):
    """상담 지식베이스 인터페이스"""

    @abstractmethod
    def search(
        self,
        query: str,
        category: Optional[str] = None,
        limit: int = 3
    ) -> List[Dict]:
        """
        정적 문서 검색

        Args:
            query: 검색 쿼리
            category: 문서 카테고리 (faq, generation_guide, modification_guide)
            limit: 반환할 문서 수

        Returns:
            [
                {
                    "content": "문서 내용...",
                    "source": "파일명",
                    "score": 0.89,
                    "metadata": {...}
                }
            ]
        """
        pass


class MockKnowledgeBase(ConsultingKnowledgeBase):
    """Mock 구현 (테스트용)"""

    def search(
        self,
        query: str,
        category: Optional[str] = None,
        limit: int = 3
    ) -> List[Dict]:
        """Mock 검색"""
        return [
            {
                "content": "카페 광고는 따뜻한 분위기와 커피 향을 연상시키는 이미지가 효과적입니다.",
                "source": "cafe_guide.md",
                "score": 0.89,
                "metadata": {"category": "generation_guide"}
            }
        ]


# 팀원이 구현할 실제 클래스
class ChromaDBKnowledgeBase(ConsultingKnowledgeBase):
    """ChromaDB 기반 지식베이스 (팀원 구현)"""

    def __init__(self, collection_name: str):
        # TODO: 팀원 구현
        pass

    def search(
        self,
        query: str,
        category: Optional[str] = None,
        limit: int = 3
    ) -> List[Dict]:
        # TODO: 팀원 구현
        pass
```

#### 4.2 chatbot.py 통합

**목표**: RAGChatbot에 지식베이스 통합

**작업 항목**:
1. RAGChatbot에 knowledge_base 인자 추가
2. process_message()에서 지식베이스 검색
3. LLM 컨텍스트에 검색 결과 추가

**우선순위**: MEDIUM

**코드 예시**:
```python
# chatbot.py

from src.backend.consulting_knowledge_base import ConsultingKnowledgeBase

class RAGChatbot:
    def __init__(
        self,
        llm_orchestrator: LLMOrchestrator,
        conversation_manager: ConversationManager,
        workflow_manager: WorkflowStateManager,
        knowledge_base: Optional[ConsultingKnowledgeBase] = None
    ):
        self.llm = llm_orchestrator
        self.conv = conversation_manager
        self.workflow = workflow_manager
        self.knowledge = knowledge_base

    async def process_message(
        self,
        db: Session,
        session_id: str,
        user_message: str,
        image_id: Optional[int] = None
    ) -> Dict:
        # ... (이전 코드)

        # 정적 파일 VectorDB 검색 (있는 경우)
        knowledge_results = []
        if self.knowledge:
            category = "faq" if intent == "consulting" else "generation_guide"
            knowledge_results = self.knowledge.search(
                query=user_message,
                category=category,
                limit=3
            )

        # 컨텍스트 구성
        context = {
            "recent_conversations": recent_conversations,
            "generation_history": generation_history,
            "knowledge_base": knowledge_results
        }

        # ... (나머지 코드)


# 싱글톤 인스턴스 생성 시 지식베이스 주입
def get_chatbot() -> RAGChatbot:
    global _chatbot_instance
    if _chatbot_instance is None:
        from src.utils.config import settings
        from src.backend.consulting_knowledge_base import MockKnowledgeBase

        llm = LLMOrchestrator(api_key=settings.OPENAI_API_KEY)
        conv = ConversationManager()
        workflow = WorkflowStateManager()
        knowledge = MockKnowledgeBase()  # 팀원 구현 후 교체

        _chatbot_instance = RAGChatbot(llm, conv, workflow, knowledge)
    return _chatbot_instance
```

---

### 단계 5: pgvector 통합 (선택사항, 2-3일)

#### 5.1 pgvector 설치 및 설정

**목표**: PostgreSQL에 pgvector 확장 설치

**작업 항목**:
1. PostgreSQL에 pgvector 설치
2. ChatHistory 테이블에 embedding 컬럼 추가
3. 임베딩 인덱스 생성

**우선순위**: LOW (선택사항)

**SQL**:
```sql
-- pgvector 설치
CREATE EXTENSION IF NOT EXISTS vector;

-- ChatHistory에 임베딩 컬럼 추가
ALTER TABLE chat_history
ADD COLUMN embedding vector(1536);

-- 유사도 검색 인덱스
CREATE INDEX idx_chat_history_embedding
ON chat_history
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);
```

#### 5.2 임베딩 생성 함수

**목표**: OpenAI Embedding API로 텍스트 임베딩 생성

**작업 항목**:
1. `utils/embedding.py` 파일 생성
2. `generate_embedding()` 함수 구현
3. ConversationManager에 통합

**우선순위**: LOW

**코드 예시**:
```python
# src/utils/embedding.py

import openai
from typing import List

def generate_embedding(text: str, model: str = "text-embedding-3-small") -> List[float]:
    """텍스트 임베딩 생성"""
    response = openai.Embedding.create(
        model=model,
        input=text
    )
    return response['data'][0]['embedding']
```

#### 5.3 ConversationManager에 벡터 검색 추가

**목표**: pgvector 기반 유사도 검색 구현

**작업 항목**:
1. `add_message()`에서 임베딩 생성 및 저장
2. `search_similar_messages()` 구현

**우선순위**: LOW

**코드 예시**:
```python
# chatbot.py: ConversationManager

from src.utils.embedding import generate_embedding

class ConversationManager:
    def add_message(
        self,
        db: Session,
        session_id: str,
        role: str,
        content: str,
        image_id: Optional[int] = None
    ) -> int:
        """메시지 저장 + 임베딩 생성"""
        # 임베딩 생성 (user 메시지만)
        embedding = None
        if role == "user":
            embedding = generate_embedding(content)

        # DB 저장
        chat_row = models.ChatHistory(
            session_id=session_id,
            role=role,
            content=content,
            image_id=image_id,
            embedding=embedding
        )
        db.add(chat_row)
        db.commit()
        db.refresh(chat_row)

        return chat_row.id

    def search_similar_messages(
        self,
        db: Session,
        query: str,
        session_id: Optional[str] = None,
        limit: int = 5
    ) -> List[Dict]:
        """유사 대화 검색 (pgvector)"""
        query_embedding = generate_embedding(query)

        # pgvector 유사도 검색
        from sqlalchemy import text

        sql = text("""
            SELECT id, role, content, created_at,
                   embedding <-> :query_embedding AS distance
            FROM chat_history
            WHERE session_id = :session_id
              AND role = 'user'
              AND embedding IS NOT NULL
            ORDER BY distance
            LIMIT :limit
        """)

        results = db.execute(
            sql,
            {
                "query_embedding": str(query_embedding),
                "session_id": session_id,
                "limit": limit
            }
        ).fetchall()

        return [
            {
                "role": row.role,
                "content": row.content,
                "timestamp": row.created_at.isoformat(),
                "similarity": 1 - row.distance  # 유사도 점수
            }
            for row in results
        ]
```

---

## 5. 코드 구현 가이드

### 5.1 코딩 스타일

**Python 스타일 가이드**:
- PEP 8 준수
- 타입 힌트 사용 (`typing` 모듈)
- Docstring 작성 (Google 스타일)

**예시**:
```python
from typing import Optional, List, Dict
from sqlalchemy.orm import Session

async def handle_chat_message(
    *,
    db: Session,
    session_id: Optional[str],
    user_id: Optional[int],
    message: str,
) -> Dict:
    """
    챗봇 메시지 처리 서비스

    Args:
        db: SQLAlchemy session
        session_id: 세션 ID (없으면 자동 생성)
        user_id: 사용자 ID (로그인 시)
        message: 사용자 메시지

    Returns:
        {
            "session_id": str,
            "assistant_message": str,
            "ready_to_generate": bool,
            "workflow_state": {...}
        }

    Raises:
        HTTPException: 챗봇 처리 실패 시
    """
    pass
```

### 5.2 에러 핸들링

**원칙**:
1. 예상 가능한 에러는 명시적으로 처리
2. 사용자에게 명확한 에러 메시지 제공
3. 로그에 상세 에러 정보 기록

**예시**:
```python
import logging
from fastapi import HTTPException

logger = logging.getLogger(__name__)

try:
    result = await some_operation()
except ValueError as e:
    logger.error(f"Invalid input: {e}", exc_info=True)
    raise HTTPException(
        status_code=400,
        detail=f"입력값이 올바르지 않습니다: {str(e)}"
    )
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    raise HTTPException(
        status_code=500,
        detail="서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요."
    )
```

### 5.3 비동기 처리

**원칙**:
1. I/O 바운드 작업은 `async/await` 사용
2. 외부 API 호출은 비동기로
3. DB 쿼리는 동기로 (SQLAlchemy ORM)

**예시**:
```python
# LLM 호출 (비동기)
async def call_llm(prompt: str) -> str:
    response = await openai.ChatCompletion.acreate(...)
    return response.choices[0].message.content

# DB 쿼리 (동기)
def get_user(db: Session, user_id: int) -> User:
    return db.query(User).filter(User.id == user_id).first()

# 혼합 사용
async def process_request(db: Session, user_id: int, prompt: str) -> Dict:
    user = get_user(db, user_id)  # 동기
    response = await call_llm(prompt)  # 비동기
    return {"user": user.name, "response": response}
```

### 5.4 로깅

**원칙**:
1. 주요 작업 시작/완료 시 로그 기록
2. 에러는 `exc_info=True`로 스택 트레이스 포함
3. 민감한 정보 (비밀번호 등) 로그에 남기지 않기

**예시**:
```python
import logging

logger = logging.getLogger(__name__)

async def handle_generate_pipeline(...):
    logger.info(f"[Pipeline {task_id}] Starting - type={generation_type}")

    try:
        # 작업 수행
        result = await generate_contents(...)
        logger.info(f"[Pipeline {task_id}] Complete - success")
        return result
    except Exception as e:
        logger.error(f"[Pipeline {task_id}] Failed - {e}", exc_info=True)
        raise
```

---

## 6. 테스트 계획

### 6.1 단위 테스트 (Unit Tests)

**목표**: 각 함수/클래스 독립 테스트

**도구**: pytest

**작성 위치**: `tests/backend/`

**예시**:
```python
# tests/backend/test_chatbot.py

import pytest
from src.backend.chatbot import WorkflowState

def test_workflow_state_completion_text():
    """텍스트 광고 워크플로우 완료 체크"""
    state = WorkflowState(
        session_id="test",
        ad_type="text",
        business_type="cafe",
        user_input="커피 광고"
    )
    assert state.check_completion() == True

def test_workflow_state_completion_image_incomplete():
    """이미지 광고 워크플로우 미완료 체크"""
    state = WorkflowState(
        session_id="test",
        ad_type="image",
        business_type="cafe",
        user_input="커피 광고"
        # style, aspect_ratio 없음
    )
    assert state.check_completion() == False
    assert "이미지 스타일" in state.get_missing_info()
```

### 6.2 통합 테스트 (Integration Tests)

**목표**: 여러 컴포넌트 통합 동작 테스트

**작성 위치**: `tests/integration/`

**예시**:
```python
# tests/integration/test_chat_flow.py

import pytest
from fastapi.testclient import TestClient
from src.backend.main import app

client = TestClient(app)

@pytest.fixture
def auth_header():
    """인증 헤더 생성"""
    response = client.post("/auth/login", data={
        "login_id": "test_user",
        "login_pw": "test_password"
    })
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}

def test_chat_to_generation_flow(auth_header):
    """챗봇 대화 → 광고 생성 전체 플로우"""

    # 1. 챗봇 메시지 (첫 질문)
    response = client.post(
        "/chat/message",
        data={"message": "카페 광고 이미지 만들고 싶어요"},
        headers=auth_header
    )
    assert response.status_code == 200
    data = response.json()
    session_id = data["session_id"]
    assert data["ready_to_generate"] == False

    # 2. 챗봇 메시지 (스타일 선택)
    response = client.post(
        "/chat/message",
        data={
            "session_id": session_id,
            "message": "사실적인 스타일로"
        },
        headers=auth_header
    )
    assert response.status_code == 200
    data = response.json()
    assert data["workflow_state"]["style"] == "ultra_realistic"

    # 3. 챗봇 메시지 (비율 선택)
    response = client.post(
        "/chat/message",
        data={
            "session_id": session_id,
            "message": "1:1 비율로"
        },
        headers=auth_header
    )
    assert response.status_code == 200
    data = response.json()
    assert data["ready_to_generate"] == True

    # 4. 광고 생성
    response = client.post(
        "/chat/generate",
        data={"session_id": session_id},
        headers=auth_header
    )
    assert response.status_code == 200
    task_id = response.json()["task_id"]

    # 5. Task 상태 확인 (최종 완료까지 대기)
    # ... (polling 로직)
```

### 6.3 E2E 테스트 (End-to-End Tests)

**목표**: 실제 사용자 시나리오 테스트

**작성 위치**: `tests/e2e/`

**시나리오**:
1. 사용자 회원가입 → 로그인
2. 챗봇 대화로 광고 정보 수집
3. 광고 생성 (텍스트/이미지)
4. 광고 수정 요청
5. 최종 확정

---

## 7. 마이그레이션 전략

### 7.1 점진적 배포 (Gradual Rollout)

**단계**:
1. **개발 환경**: chatbot.py 구현 및 테스트
2. **스테이징 환경**: 통합 테스트
3. **프로덕션 환경**: 새 API 엔드포인트 배포 (기존 유지)
4. **프론트엔드 전환**: 점진적으로 새 API로 전환
5. **기존 API 제거**: 완전 전환 후 deprecated

### 7.2 호환성 유지

**원칙**:
- 기존 `/generate` 엔드포인트는 그대로 유지
- 새로운 `/chat/*` 엔드포인트 별도 추가
- 프론트엔드는 점진적 전환 가능

**엔드포인트 버전 관리**:
```
기존 (유지):
POST /api/generate  # 단발성 광고 생성

신규 (추가):
POST /api/chat/message   # 챗봇 대화
POST /api/chat/generate  # 챗봇 기반 생성
POST /api/chat/revise    # 광고 수정
POST /api/chat/confirm   # 광고 확정
```

### 7.3 데이터 마이그레이션

**DB 스키마 변경**:
1. GenerationHistory에 컬럼 추가 (nullable)
2. 기존 데이터는 영향 없음
3. 새 데이터부터 is_confirmed, revision 사용

**마이그레이션 스크립트**:
```sql
-- Step 1: 컬럼 추가 (nullable)
ALTER TABLE generation_history
ADD COLUMN is_confirmed BOOLEAN DEFAULT FALSE;

ALTER TABLE generation_history
ADD COLUMN revision_of_id INTEGER;

ALTER TABLE generation_history
ADD COLUMN revision_number INTEGER DEFAULT 0;

-- Step 2: 외래키 추가
ALTER TABLE generation_history
ADD CONSTRAINT fk_revision_of
FOREIGN KEY (revision_of_id) REFERENCES generation_history(id);

-- Step 3: 기존 데이터 업데이트 (선택)
UPDATE generation_history
SET is_confirmed = TRUE
WHERE created_at < '2026-01-15';  -- 리팩토링 이전 데이터는 모두 확정된 것으로 간주
```

### 7.4 롤백 계획

**문제 발생 시 롤백 전략**:
1. 새 엔드포인트만 비활성화 (기존 유지)
2. DB 스키마 변경은 롤백 불필요 (nullable 컬럼)
3. 프론트엔드 캐시 클리어

**모니터링**:
- 에러율 추적
- 응답 시간 모니터링
- LLM API 사용량 추적

---

## 8. 리팩토링 체크리스트

### Phase 1: 기반 구조 (1-2일) ✅ 완료

- [x] `chatbot.py` 스켈레톤 생성
  - [x] ConversationManager 클래스
  - [x] LLMOrchestrator 클래스
  - [x] RAGChatbot 클래스
  - [x] get_chatbot() 싱글톤 함수
- [x] DB 스키마 확장
  - [x] models.py: GenerationHistory에 컬럼 추가
  - [x] 마이그레이션 스크립트 작성 (Alembic 설정 완료)
    - [x] alembic.ini 설정
    - [x] alembic/env.py 작성
    - [x] 001_add_generation_revision_columns.py 마이그레이션
- [x] schemas.py 확장
  - [x] ReviseRequest 스키마
  - [x] ConfirmRequest 스키마

### Phase 2: RAG 챗봇 핵심 (3-4일) ✅ 완료

- [x] ConversationManager 구현
  - [x] add_message() 함수
  - [x] get_recent_messages() 함수
  - [x] get_generation_history() 함수
  - [x] search_similar_messages() 스텁
- [x] LLMOrchestrator 구현
  - [x] analyze_intent() 함수 (모든 경우에 사용)
  - [x] generate_consulting_response() 함수 (상담 intent만)
  - [x] 프롬프트 템플릿 작성
- [x] RAGChatbot.process_message() 구현
  - [x] 의도 분석 통합
  - [x] VectorDB 검색 통합
  - [x] Intent별 분기 처리 (생성/수정 vs 상담)
  - [x] 대화 저장
- [x] services.py 업데이트
  - [x] handle_chat_message() 완성 (Intent별 분기 처리)
  - [x] 생성/수정 intent → 생성 파이프라인 호출
  - [x] 상담 intent → 상담 응답 반환

### Phase 3: 수정/컨펌 플로우 (2-3일) ✅ 완료

- [x] services.py 보완
  - [x] handle_chat_revise() 함수
  - [x] handle_chat_confirm() 함수
  - [x] _parse_revision_request() 헬퍼 함수 (키워드 기반 파싱)
- [x] routers/chat.py 보완
  - [x] POST /chat/revise 엔드포인트
  - [x] POST /chat/confirm 엔드포인트
  - [x] GET /chat/generation/{session_id} 엔드포인트 (생성 이력 조회)
- [x] process_db.py 보완
  - [x] get_latest_generation() 함수
  - [x] get_latest_unconfirmed_generation() 함수
  - [x] confirm_generation() 함수
  - [x] save_generation_history_with_revision() 함수

### Phase 4: 정적 파일 VectorDB (2-3일) ✅ 완료 (Mock 구현)

- [x] consulting_knowledge_base.py 작성
  - [x] ConsultingKnowledgeBase 인터페이스 (추상 클래스)
  - [x] MockKnowledgeBase 구현 (테스트/개발용)
  - [x] ChromaDBKnowledgeBase 템플릿 (팀원 구현용)
  - [x] get_knowledge_base() 싱글톤 함수
- [x] chatbot.py 통합
  - [x] RAGChatbot에 knowledge_base 파라미터
  - [x] process_message()에서 지식베이스 검색
  - [x] get_chatbot()에서 knowledge_base 주입
- [ ] 팀원 협업 (대기 중)
  - [x] 인터페이스 문서 공유 (consulting_knowledge_base.py 참조)
  - [ ] 실제 ChromaDB 구현 대기/통합

### Phase 5: 대화 히스토리 → 생성 프롬프트 연동 (1-2일) ✅ 완료

- [x] 텍스트 생성 모듈 수정
  - [x] `text_generator.py`: `conversation_history` 파라미터 추가
  - [x] `_build_user_prompt()`: 대화 맥락 프롬프트 구성
- [x] 이미지 생성 모듈 수정
  - [x] `prompt_manager.py`: `conversation_history` 파라미터 추가
  - [x] `generator.py`: `conversation_history` 파라미터 추가
- [x] 백엔드 서비스 연동
  - [x] `generate_contents()`: conversation_history 파라미터 추가
  - [x] `handle_generate_pipeline()`: 대화 히스토리 조회 및 전달
  - [x] `_run_generation_for_intent()`: 대화 히스토리 조회 및 전달
  - [x] `handle_chat_revise()`: 대화 히스토리 조회 및 전달

### Phase 5-B: pgvector 통합 (선택, 2-3일) ✅ 완료

- [x] PostgreSQL pgvector 설치 (마이그레이션에 포함)
- [x] DB 스키마 변경 (embedding 컬럼)
  - [x] models.py: ChatHistory에 embedding vector(1536) 컬럼 추가
  - [x] alembic 마이그레이션: 002_add_pgvector_embedding.py 생성
  - [x] IVFFlat 인덱스 생성 (빠른 유사도 검색)
- [x] utils/embedding.py 작성
  - [x] generate_embedding() 함수 (동기)
  - [x] generate_embedding_async() 함수 (비동기)
  - [x] calculate_cosine_similarity() 함수
- [x] ConversationManager 업데이트
  - [x] add_message(): 임베딩 생성 및 저장 (user 메시지만)
  - [x] search_similar_messages(): pgvector 기반 코사인 유사도 검색 구현
- [x] 문서 작성
  - [x] pgvector_통합_가이드.md (상세 사용법)
  - [x] Phase_5B_pgvector_설치_가이드.md (설치 및 설정)

### Phase 6: 테스트 및 배포 (2-3일)

- [ ] 단위 테스트 작성
  - [ ] chatbot.py 테스트
  - [ ] services.py 테스트
- [ ] 통합 테스트 작성
  - [ ] RAG 파이프라인 테스트
  - [ ] 수정/컨펌 플로우 테스트
- [ ] E2E 테스트 작성
- [ ] 스테이징 배포 및 QA
- [ ] 프로덕션 배포
- [ ] 모니터링 설정

---

## 9. 예상 일정

| 단계 | 작업 내용 | 예상 소요 시간 | 담당 |
|-----|----------|------------|------|
| Phase 1 | 기반 구조 구축 | 1-2일 | 백엔드 로직 |
| Phase 2 | RAG 챗봇 핵심 구현 | 3-4일 | 백엔드 로직 |
| Phase 3 | 수정/컨펌 플로우 | 2-3일 | 백엔드 로직 |
| Phase 4 | 정적 파일 VectorDB 통합 | 2-3일 | 백엔드 + 상담 챗봇 팀원 |
| Phase 5 | pgvector 통합 (선택) | 2-3일 | 백엔드 로직 |
| Phase 6 | 테스트 및 배포 | 2-3일 | 전체 팀 |
| **총계** | | **12-18일 (약 2.5-4주)** | |

**우선순위 조정**:
- HIGH: Phase 1, 2, 3 (필수 기능)
- MEDIUM: Phase 4 (협업 필요)
- LOW: Phase 5 (선택사항, 성
---

## 10. 협업 포인트

### 10.1 상담 챗봇 팀원과 협업

**필요한 협업**:
1. 정적 파일 VectorDB 인터페이스 정의
2. 검색 API 구현 및 통합
3. FAQ 문서 관리 전략

**협업 일정**:
- Phase 4에서 통합 (Phase 2 완료 후)
- 인터페이스 먼저 정의 후 병렬 작업 가능

### 10.2 프론트엔드 팀과 협업

**필요한 협업**:
1. 새 API 엔드포인트 문서 공유
2. 워크플로우 상태 UI 설계
3. Task 진행률 폴링 로직

**협업 일정**:
- Phase 2 완료 후 API 문서 공유
- Phase 3 완료 후 수정/컨펌 UI 개발
- 점진적 전환 계획 협의

---

**문서 작성**: Claude Code (Backend Developer Agent)
**검토 필요**: 백엔드 로직 담당자, 팀 리더
**마지막 업데이트**: 2026-01-16
