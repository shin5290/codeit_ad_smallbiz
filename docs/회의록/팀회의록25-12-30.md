---
layout: default
title: "팀 회의록 - 2025-12-30 - 코드잇 AI 4기 4팀"
description: "팀 회의록 - 2025-12-30 - 코드잇 AI 4기 4팀"
date: 2025-12-30
author: "신승목"
cache-control: no-cache
expires: 0
pragma: no-cache
---

# 팀 회의록 - 2025-12-230

## 회의 기본 정보
**날짜**: 2025-12-30
**시간**: 9:00~18:50
**회의 유형**: 아키텍처 및 역할 배정
**참석자**: 코드잇 AI 4기 4팀
**회의 주도**: 신승목

---

## 회의 목적
각자 조사한 내용을 바탕으로 전체 프로젝트의 아키텍처를 결정
프로젝트에 필요한 요소들을 구성할 역할 배정

---

## 주요 안건 및 논의사항

### 1. 팀 목표 설정
**핵심 목표**:
- 고급 과제를 포트폴리오로 적극 활용
- 과제 완료 후 포트폴리오 수준의 결과물 도출

### 2. 핵심 논의사항
**주요 이슈**:
- 전체 프로젝트 아키텍처 결정
- 각 인원의 역할 배정

**팀 결정사항**:
- 아키텍처 구성 내용: 구현 기능 1차 목표 (이후에 핵심 목표에 추가할 예정)
    - **서비스 이용 주체(고정)**: 소상공인, **업종의 제약 없이** 생성할 수 있도록
    - **서비스 목적(고정)**: 생성형 AI 기술을 활용한 소상공인이 광고 콘텐츠를 손쉽게 제작할 수 있는 서비스 홍보 디자인 및 마케팅 문구
    - 광고 이미지 만들기 1(자율): **텍스트 입력만(12/31 기준)**
        - 입력: 광고 문구 또는 이미지에 대한 요청 사항
        - 출력: 광고 문구 또는 요청 사항에 맞춰 제작된 이미지

### 3. 역할 배정
**(1) 프론트엔드 + 백엔드 API : 이유노**
    - 영역: frontend/, backend/routes.py
    - 업무: UI 구성, 전체 결과 렌더링, FastAPI RESTful API 구현
        - UI 구성은 Streamlit 대신 React 등 다른 선택지 고려 중(12/31 기준)
        - js나 React 사용해서 버셀로 자동 배포
    - 산출: 모든 페이지, 사용자 플로우
    - 포인트: "직관적 UI/UX 설계 및 구현"
        - /frontend 에서 app.py, ui_components.py, backend_client.py 작성
        - /backend 에서 routes.py 작성

    ✅ app.py - Streamlit 메인 앱
    - 역할: 직접적인 코드 없이 요청 받는 내용만 수행
    ✅ ui_components.py - 모든 UI 컴포넌트 통합
    - 역할: 전체 화면에 어떤 내용이 어디에 위치할 지 구성
    1. 챗봇 UI 구성(사용자가 AI와 주고받는 내용이 챗봇 UI 안에서 진행)
        - 입력 폼(사용자가 필요한 광고에 대한 요청 사항 입력하는 공간)
            - 생성할 이미지의 비율을 선택할 수 있도록 프리셋 제공 (1:1, 4:3, 3:4)
        - 결과 표시(사용자 요청에 대한 최종 응답 결과)
            - 생성된 광고에 대한 UI 제공, 생성된 광고 내용(이미지, 광고 문구, 혹은 둘 다) 표시
            - 추론에 시간이 걸리기 때문에 추론이 진행중임을 표현할 수 있는 장치 필요(spinner 형태)
    2. 우측 상단에 (회원가입 및 로그인)을 수행할 수 있는 버튼
        - 회원가입 시 user_id, user_pw를 입력(유효성 검사는 다른 영역에서 수행)
        - 로그인 시 user_id, user_pw를 입력(유효성 검사는 다른 영역에서 수행)
    3. 광고 생성 이력 표시 UI: 챗봇 UI 아래에 구성
        - (아키텍처에서 내용 추가 필요)
        - 로그인 시 해당 회원의 광고 생성 이력만 보이도록 설정
        - 이미지를 작게 썸네일로 보여줘서 클릭하면 상세한 내용이 보일 수 있게 구성
    4. 채팅 이력 표시 UI: 챗봇 UI 아래에 구성
        - 아키텍처에서 내용 추가 필요
            - 페이지가 보이게 하는 기준을 정해야 합니다.
                - 최초 채팅 시각
                - 사용자가 입력한 내용에서 앞 10글자 정도 보이게 해서 사용자가 선택할 수 있게 할 것인지
    5. (추가) 브랜드 설정 UI: sidebar에 구성
        - 목적: 기존에 생성된 광고 내용을 바탕으로 퀄리티가 향상될 수 있도록 하기 위함
        - 생성된 광고 이미지가 생성 모델에 들어갈 수 있도록 설정 필요
    6. (추가) 오늘의 추천 표시: sidebar에 구성
        - 목적: 계절이나 기념일에 따라 특별한 내용의 광고가 필요할 수 있는 업종에는 해당 정보 제공
    ✅ backend_client.py
    - 역할: FastAPI 통신 클라이언트로 백엔드에 전달할 수 있게 구성
    1. 이미지 생성 요청 텍스트를 백엔드에 전달할 수 있게 구성
    2. 챗봇 대화 형식에 대한 구성
        - UI 프레임 내에서 사용자 입력 내용을 오른쪽, AI 응답을 왼쪽에 표시
    3. 회원 가입 및 로그인에 대한 구성
        - 회원가입: 사용자가 입력한 user_id, user_pw를 user.db 저장하는 쪽에 전달
            - user_id 중복 오류 정보를 받았을 때 오류 메시지 나오게 구성
        - 로그인: 로그인 정보를 전달, 성공/실패 신호를 받았을 때 서로 다른 반응이 나오도록 구성
            - 성공: 해당 로그인 정보에 해당하는 광고 생성 이력과 채팅 이력만 볼 수 있도록 설정
            - 실패: 오류 메시지와 함께 로그인 미진행
    ✅ routes.py
    - 역할: FastAPI로 프론트쪽과 엔드포인트 설정
    1. 프론트에서 보낸 광고 생성 요청 내용을 받음
    2. 해당 요청을 프롬프트 생성 쪽에 전달
    3. 생성 쪽에 요청을 보내고 결과가 나오기까지 작업 상태 확인
        (진행 중인지, 오류가 발생하였는지 등)
    4. 해당 작업 상태 확인 내용을 프론트에 전달
    5. 프론트에서 DB 관련 요청 시 필요한 내용을 주고 받을 수 있는 구조 형성
        (회원가입, 로그인, 광고 생성 이력, 채팅 이력 등)

**(2) 백엔드 - 비즈니스 로직 통합: 진수경**
    - 영역: backend/
    - 업무:
        - DB 스키마 설계 및 CRUD
        - 이미지/텍스트 생성 모듈 호출 및 결과 저장
    - 산출: PostgreSQL 스키마
    - 포인트: "확장 가능한 백엔드 아키텍처 및 데이터 관리"

    ✅ services.py
    - 역할: 비즈니스 로직 통합
    - 이미지 생성, 텍스트 생성에 대한 워크플로우 구성
        - 광고를 생성할 수 있도록 요청을 보내는 기능
        - 생성된 광고를 받아서 프론트엔드에 보낼 수 있는 기능
    - 챗봇 로직 + 대화 이력을 chat_history.db에 저장
    - (추가) 
    ✅ db_processor.py (process_db.py보다는 기능이 덜 혼동될 것으로 개인적 생각)
    - PostgreSQL 사용
    - db에 무엇을 저장할 지 정의 (12/31 결정한 db 상세 내용은 아래 "DB 내용 구상"에서 서술)
    - DB에 대한 CRUD 수행
    - db에 저장할 데이터 설정, 제약 조건 설정

    ✅ schemas.py - Pydantic schema
    - 프론트/백엔드 요청/응답에 대한 검증 작성
    - 요청 내용을 클래스 형태로 정의

**(3) 이미지 생성: 이현석**
    - 영역: generation/image_generation
    - 업무:
        - 자동 모델 선택 로직 (입력 분석 → t2i/ControlNet)
        - 이미지 품질 분석 및 전처리 (배경 제거, 밝기 조정)
        - SDXL/QWEN/Flux.1 + ControlNet 파이프라인 구현
        - 이미지 후처리 (리사이징, 압축, 텍스트 오버레이)
    - 산출: UnifiedImageGenerator 클래스
    - 포인트: "SDXL/QWEN/Flux.1 중 하나의 모델 기반 이미지 생성 및 자동 선택 알고리즘"

    - 모델 선택 기준: 생성 시간
        - (우선) SDXL(기본), Flux.1(고품질)
        - (선택, 후순위) QWEN image(QWEN 파생 모델, 생성 시간 제일 느림)
        - 모델의 생성시간이 사용자 경험(UX)에 중요하기 때문에 이미지 생성 시간을 고려해서 고품질 모델의 생성 시간이 너무 길면 SDXL 선택
        - 이미지 생성에 사람이 들어갈 때 고려해야 할 요소
            - sdxl(애니메이션 쪽), flux(범용적), qwen(실사)
            - 어떻게 넣을 것인지(방법론적 내용 또는 기술적인 내용)
            - 분위기를 어떻게 중점으로 가져갈 것인지(분위기를 이미지 생성 프롬프트에 반영)
    - 모델에 필요한 입력
        - 태그 기반으로 입력을 받는다.
        - 입력할 태그는 사용자 요청 내용을 GPT에 보내서 태그를 입력 받는다.
    - 이미지 생성
        - (우선) t2i 형태로 텍스트 입력
        - (다음) 사용자가 로고 이미지를 넣어서 반영할 수 있게 설정하여 생성 모델에 함께 입력
    - 이미지 후처리
        - 리사이징
            - 프론트에서 UI로 생성할 이미지의 비율을 선택할 수 있도록 프리셋 제공 (1:1, 4:3, 3:4)
        - 텍스트 오버레이
        - (선택) 사용자가 입력한 로고를 어떻게 적용할 지는 추가 조사 필요
            - 텍스트 만으로 생성된 이미지 결과에 로고 이미지를 덮어씌우기
            - 로고 이미지를 이미지 생성에 반영하도록 할 지 여부는 추후에 결정
        - 품질 최적화 + 용량 압축

    ✅ UnifiedImageGenerator 클래스 주요 함수:
        generate() - 자동 모델 선택 및 이미지 생성 총괄
        analyze_image_quality() - 이미지 품질 분석
        decide_generation_method() - t2i/ControlNet 자동 선택
        preprocess_image() - 배경 제거, 밝기 조정
        generate_t2i() - 텍스트→이미지 생성
        generate_controlnet() - ControlNet 기반 생성
        postprocess_image() - 리사이징, 압축, 텍스트 오버레이

**(4) 텍스트 & 프롬프트 생성: 배현석**
    - 영역: models/text_generation/
    - 업무:
        - GPT API 연동 및 광고 카피 생성
        - 이미지 생성용 프롬프트 템플릿 설계 (업종별/스타일별)
        - 텍스트 생성용 프롬프트 템플릿 설계 (톤앤매너별)
        - 응답 파싱 및 검증
    - 산출: TextGenerator 클래스, PromptTemplateManager 클래스
    - 포인트: "GPT 기반 광고 카피 생성 및 통합 프롬프트 엔지니어링"
    ✅ 프롬프트 생성 클래스
    - (입력: 사용자 요청을 변환한 내용, 이미지/텍스트 생성 구분 변수)
    - (출력: 프롬프트, 이미지 생성용과 텍스트 생성용으로 분리)
    - 이미지 생성에 쓰일 프롬프트와 텍스트 생성에 사용할 프롬프트 분리
    - 프롬프트 생성 시 템플릿+키워드(카페, 메뉴, 계절, 스타일 등) 등을 동원해서 프롬프트 생성
    - 키워드 출처: DB 또는 사용자 입력 내용
    ✅ 텍스트 생성 클래스
    - 텍스트 생성용 프롬프트를 바탕으로 API와 연동하여 필요한 텍스트 생성
    - 해당 텍스트는 이미지에 추가할 텍스트 내용 또는 사용자가 텍스트만 요청했을 때는 

**(5) 인프라: 신승목**
    - 영역: deployment/, tests/, backend/utils/
    - 업무: Docker, Cloud Run 배포, GPU 인스턴스 설정, GCS, CI/CD
    - 산출: Dockerfile, CI/CD 파이프라인, 공통 유틸
    - 포인트: "클라우드 인프라 구축 및 배포 자동화"
    1. Docker 관련 (deployment/docker/)
        - Streamlit 컨테이너,  FastAPI 컨테이너
        - GPU 서버 컨테이너 (선택), 
        - 전체 서비스 오케스트레이션, 불필요 파일 제외
    2. 배포 스크립트 (deployment/scripts/)
        - GPU 서버 초기 셋업, Streamlit Cloud 배포
        - Cloud Run 배포, DB 마이그레이션
    3. CI/CD (.github/workflows/)
        - 자동 테스트, 자동 배포, 코드 품질 체크
    4. 공통 유틸 (utils/)
        - database.py, 데이터베이스에 저장 수행 - 백엔드 쪽과 연결된 내용
        - storage.py
            - 생성된 이미지를 사용자가 공유하거나 저장할 수 있게 버튼에 맞는 응답 구성
            - 이미지 파일을 로컬이나 클라우드에 저장
                - 이미지를 불러오는 DB에는 이미지의 해시값과 경로를 매칭해서 저장
                - 이미지 호출 시 DB에서 해당 해시에 연결된 이미지를 반환할 수 있게 하는 설정 필요
            - 생성할 디렉토리를 지정해주고 해당 위치에 저장하거나 제거할 때 사용
        - validators.py, 유효성 검증
        - config.py
        - (우선) logging_config.py
    5. 테스트 (tests/)
        - API 테스트, AI 모델 테스트, 통합 테스트

### 4. DB 내용 구상 (12/31 기준)
각 db의 연결 구조 이미지는 251230_db_초기연결구조.png 참조
**generation_history.db**: 광고 컨텐츠 생성 기록
- id(int):  이미지 생성 기록 pk
- user_id(ink) : 사용자가 회원 가입 시 자동으로 부여되는 번호, 비회원 Null값 허용(FK)
- input_text(text): 사용자가 입력한 내용
- input_image_url(text): 이미지 입력 시 url
    - 이미지 입력을 url로 처리하는 과정이 추가로 들어가야 하는 것인가?
- content_type (image/text): 생성된 컨텐츠의 타입
- output_url(text): 생성된 이미지의 url변환 값
    - 사용 목적: 이미지 자체 보다 텍스트 형태의 자료형을 DB에 저장하는 것, url과 text 가능
    - GCS에 저장하고 받은 url (GCS의 무료 공간 5GB)
    - 생성된 이미지의 해시값을 대신 사용해 볼 수 있지 않을까 생각
- generation_method(text): t2i/ControlNet
- style(text): API로 이미지 생성 시 사용했던 스타일 정보 (프롬프트에 포함된 태그 정보)
- industry(text): 업종
- created_at(text → timestamp)
- seed(int) : 해당 이미지 생성 시 사용된 시드, 해당 시드를 바탕으로 이미지의 스타일을 유지해서 퀄리티를 향상시켜 나갈 수 있을 것으로 기대

**chat_history.db**: 챗봇과 채팅 기록
- id(int):  챗봇과 채팅 기록의 pk
- user_id(int) : 사용자가 회원 가입 시 자동으로 부여되는 번호, 비회원 Null값 허용(FK)
- message_id(int): 해당 세션에서 주고받은 대화 번호
- session_id: (text)(해시처럼 임의 생성, 세션이 유지되어 있다면 같은 값), 세션 삭제 기능으로 같은 session_id 삭제
- role: (text) assistant, user
- content: (text) user와 assistant가 주고받은 대화 내용
- input_image_hash:(text) 사용자가 생성 시 입력한 원본 이미지를 서버의 “입력 이미지 저장소”에 저장하고 해시값을 db에 저장
- gen_image_url:(text) content 전달 시 이미지를 전달했다면 해당 url 같이 저장, 생성한 이미지 전달 시에만 활용
    - 전달하지 않는 경우에는 NULL로 저장

**user.db**: 회원가입 정보
- user_id(int): 회원 가입 시 자동 부여되는 번호
- login_id(text): 사용자 지정 아이디
- login_pw(text): 사용자 비밀번호

- 회원 가입 도입 목적: 유저를 특정해서 확인할 수 있게, 최대한 간단한 수준으로 구성
    - 로그인 한 상황이면 해당 id와 일치하는 이전 세션 불러오기
    - 비로그인 환경에서는 지난 기록 확인 불가
    - db에서 id와 user_id를 받아와서 매칭시키는 함수 또는 생성자 필요한지는 확인해서 구성

**gen_image_matching.db**: 생성된 이미지의 해시값과 디렉토리 매칭용 DB
- 목적: 생성된 이미지에 대해 파일 해시 값을 계산해서 파일 해시와 파일 저장 디렉토리를 매칭한 내용을 해당 DB에 저장
- 사용자가 입력한 이미지
    - id(int): 사용자 회원 번호
    - file_hash(text) : 해당 이미지의 파일 해시(SHA-256)
    - file_directory(text) : 원본 이미지가 저장되어 있는 디렉토리

**input_image_matching.db**: 생성된 이미지의 해시값과 디렉토리 매칭용 DB
- 목적: 사용자가 API에 입력한 이미지를 재사용할 수 있게 하기 위함
- 구조: 사용자가 API에 입력한 이미지에 파일 해시 값을 계산해서 파일 해시와 파일 저장 디렉토리를 매칭한 내용을 DB에 저장, 
- 사용자가 입력한 이미지
    - id(int): 사용자 회원 번호
    - file_hash(text) : 해당 이미지의 파일 해시(SHA-256)
    - file_directory(text) : 원본 이미지가 저장되어 있는 디렉토리

### 5. 환경 설정
**완료 사항**:

---

## 역할 분담 및 액션 아이템

| 담당자 | 업무 | 마감일 | 우선순위 |
|--------|------|--------|----------|
| 전원 | 아키텍처 구성 및 역할 배정 | 12/30 (화) | 높음 |

---

## 다음 회의
**일정**: 2025-12-31 (수)
**안건**:
- 각 역할별로 필요한 작업 결정
**준비사항**:
- 각 역할에 대한 이해

---

## 기타 사항
**참고 링크**:
- [Github Repo](https://github.com/shin5290/codeit_ad_smallbiz)

**공유 자료**:
- 

**특이사항**:
- 

---

**작성자**: 신승목
**작성 시간**: 2025-12-31